<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>í­íƒ„ì°¾ê¸° ê²Œì„ - ì‹ ìš°í˜„ì˜ í™ˆí˜ì´ì§€</title>
    <meta name="description" content="HTMLê³¼ ìë°”ìŠ¤í¬ë¦½íŠ¸ë¡œ êµ¬í˜„ëœ í­íƒ„ì°¾ê¸°(Minesweeper) ê²Œì„ì„ ì¦ê²¨ë³´ì„¸ìš”.">
    <link rel="stylesheet" href="css/style.css">
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ğŸ§¨</text></svg>">
</head>
<body>
    <!-- ë„¤ë¹„ê²Œì´ì…˜ -->
    <nav>
        <div class="nav-container">
            <a href="index.html" class="logo">ì‹ ìš°í˜„</a>
            <ul class="nav-links">
                <li><a href="index.html">í™ˆ</a></li>
                <li><a href="baseball.html">í”„ë¡œì•¼êµ¬</a></li>
                <li><a href="baduk.html">ë°”ë‘‘</a></li>
                <li><a href="game.html" class="active">ê²Œì„</a></li>
                <li><a href="game2.html">ê²Œì„2</a></li>
            </ul>
            <div class="hamburger" onclick="toggleMobileMenu()">
                <span></span>
                <span></span>
                <span></span>
            </div>
        </div>
    </nav>

    <!-- ë©”ì¸ ì½˜í…ì¸  -->
    <main>
        <section class="section">
            <div class="container">
                <div class="page-header">
                    <h1>ğŸ§¨ í­íƒ„ì°¾ê¸° ê²Œì„</h1>
                    <p>ê³ ì „ Minesweeper ê²Œì„ì„ ë¸Œë¼ìš°ì €ì—ì„œ ë°”ë¡œ ì¦ê²¨ë³´ì„¸ìš”.</p>
                </div>
                <div class="card-grid">
                    <article class="card" role="region" aria-labelledby="game-howto">
                        <h3 id="game-howto">ğŸ¯ í”Œë ˆì´ ë°©ë²•</h3>
                        <p>ì²« ì¹¸ì„ ì—´ë©´ ì§€ë¢°ê°€ ì—†ëŠ” ì•ˆì „ì§€ëŒ€ê°€ í¼ì³ì§€ê³ , ìˆ«ìëŠ” ì£¼ë³€ 8ì¹¸ì˜ ì§€ë¢° ê°œìˆ˜ë¥¼ ëœ»í•©ë‹ˆë‹¤. ê¹ƒë°œì„ í™œìš©í•´ ì§€ë¢° ìœ„ì¹˜ë¥¼ í‘œì‹œí•˜ì„¸ìš”.</p>
                        <ul class="game-tips">
                            <li>ì§§ê²Œ í´ë¦­(íƒ­)í•˜ë©´ í•´ë‹¹ ì¹¸ì„ ì—½ë‹ˆë‹¤</li>
                            <li>ì˜¤ë¥¸ìª½ í´ë¦­, ë‘ ì†ê°€ë½ íƒ­ ë˜ëŠ” ê¸¸ê²Œ ëˆŒëŸ¬ ê¹ƒë°œì„ í† ê¸€í•©ë‹ˆë‹¤</li>
                            <li>ëª¨ë“  ì§€ë¢°ë¥¼ í‘œì‹œí•˜ê±°ë‚˜ ì•ˆì „í•œ ì¹¸ì„ ëª¨ë‘ ì—´ë©´ ìŠ¹ë¦¬í•©ë‹ˆë‹¤</li>
                        </ul>
                    </article>
                    <article class="card" role="region" aria-labelledby="game-source">
                        <h3 id="game-source">ğŸ’» ì˜¤í”ˆì†ŒìŠ¤</h3>
                        <p>ì´ ê²Œì„ì€ <em>nickarocho/minesweeper</em> ì˜¤í”ˆì†ŒìŠ¤ë¥¼ ì°¸ê³ í•˜ì—¬ ì œì‘ë˜ì—ˆìŠµë‹ˆë‹¤. ê³µê°œ ë¼ì´ì„ ìŠ¤ë¥¼ ì¤€ìˆ˜í•˜ë©°, í•™ìŠµê³¼ ì¬ë¯¸ë¥¼ ìœ„í•œ ëª©ì ì…ë‹ˆë‹¤.</p>
                        <p style="margin-bottom: 0;">ë‚œì´ë„ì— ë”°ë¼ ì§€ë¢° ìˆ˜ê°€ ë‹¬ë¼ì§€ë‹ˆ ì—¬ëŸ¬ ë‚œì´ë„ë¡œ ë„ì „í•´ë³´ì„¸ìš”!</p>
                    </article>
                </div>
            </div>
        </section>

        <section class="section">
            <div class="container">
                <article class="card game-card" role="region" aria-label="í­íƒ„ì°¾ê¸° ê²Œì„">
                    <div class="game-toolbar">
                        <div class="game-controls">
                            <label for="difficulty" class="sr-only">ë‚œì´ë„ ì„ íƒ</label>
                            <select id="difficulty" aria-label="ë‚œì´ë„ ì„ íƒ">
                                <option value="easy">ì‰¬ì›€ Â· 9x9 Â· ì§€ë¢° 10ê°œ</option>
                                <option value="medium" selected>ë³´í†µ Â· 12x12 Â· ì§€ë¢° 22ê°œ</option>
                                <option value="hard">ì–´ë ¤ì›€ Â· 14x14 Â· ì§€ë¢° 30ê°œ</option>
                            </select>
                            <button class="btn" id="resetGame" type="button">ë‹¤ì‹œ ì‹œì‘</button>
                        </div>
                        <div class="game-stats" aria-live="polite">
                            <span>ì§€ë¢°: <strong id="mineTotal">0</strong></span>
                            <span>í‘œì‹œ: <strong id="flagCount">0</strong></span>
                            <span>ì‹œê°„: <strong id="timerDisplay">0</strong>s</span>
                        </div>
                    </div>
                    <div id="statusMessage" class="game-status" role="status" aria-live="polite">ì²« ì¹¸ì„ ì—´ì–´ë³´ì„¸ìš”! ê¸¸ê²Œ ëˆŒëŸ¬ ê¹ƒë°œì„ í‘œì‹œí•  ìˆ˜ ìˆì–´ìš”.</div>
                    <div id="minefield" class="minefield" role="grid" aria-label="í­íƒ„ì°¾ê¸° ê²Œì„íŒ"></div>
                </article>
            </div>
        </section>
    </main>

    <!-- í‘¸í„° -->
    <footer>
        <div class="container">
            <p>&copy; 2024 ì‹ ìš°í˜„ì˜ í™ˆí˜ì´ì§€. ì¦ê±°ìš´ ê²Œì„ ì‹œê°„ ë˜ì„¸ìš”! ğŸ§¨</p>
        </div>
    </footer>

    <script src="js/script.js"></script>
    <script>
        // Minesweeper implementation inspired by https://github.com/nickarocho/minesweeper
        (function() {
            const difficultyMap = {
                easy: { width: 9, height: 9, mines: 10 },
                medium: { width: 12, height: 12, mines: 22 },
                hard: { width: 14, height: 14, mines: 30 }
            };
            const LONG_PRESS_DELAY = 500;
            const pointerTimers = new Map();

            const minefieldEl = document.getElementById('minefield');
            const difficultyEl = document.getElementById('difficulty');
            const resetBtn = document.getElementById('resetGame');
            const mineTotalEl = document.getElementById('mineTotal');
            const flagCountEl = document.getElementById('flagCount');
            const timerDisplayEl = document.getElementById('timerDisplay');
            const statusMessageEl = document.getElementById('statusMessage');

            let cells = [];
            let boardConfig = { width: 0, height: 0, mines: 0 };
            let boardGenerated = false;
            let revealedCount = 0;
            let flagCount = 0;
            let timerId = null;
            let secondsElapsed = 0;
            let gameOver = false;

            function indexFromXY(x, y) {
                return y * boardConfig.width + x;
            }

            function getNeighbors(x, y) {
                const result = [];
                for (let dy = -1; dy <= 1; dy++) {
                    for (let dx = -1; dx <= 1; dx++) {
                        if (dx === 0 && dy === 0) continue;
                        const nx = x + dx;
                        const ny = y + dy;
                        if (nx >= 0 && nx < boardConfig.width && ny >= 0 && ny < boardConfig.height) {
                            result.push({ x: nx, y: ny, index: indexFromXY(nx, ny) });
                        }
                    }
                }
                return result;
            }

            function startTimer() {
                if (timerId) return;
                timerId = setInterval(() => {
                    secondsElapsed += 1;
                    timerDisplayEl.textContent = secondsElapsed;
                }, 1000);
            }

            function stopTimer() {
                if (timerId) {
                    clearInterval(timerId);
                    timerId = null;
                }
            }

            function updateStats() {
                mineTotalEl.textContent = boardConfig.mines;
                flagCountEl.textContent = flagCount;
            }

            function setStatus(message) {
                statusMessageEl.textContent = message;
            }

            function resetGame() {
                stopTimer();
                boardGenerated = false;
                revealedCount = 0;
                flagCount = 0;
                secondsElapsed = 0;
                timerDisplayEl.textContent = '0';
                gameOver = false;
                minefieldEl.innerHTML = '';
                pointerTimers.forEach(({ timerId }) => clearTimeout(timerId));
                pointerTimers.clear();

                const config = difficultyMap[difficultyEl.value];
                boardConfig = { ...config };
                minefieldEl.style.setProperty('--cols', boardConfig.width);
                minefieldEl.setAttribute('aria-rowcount', boardConfig.height);
                minefieldEl.setAttribute('aria-colcount', boardConfig.width);

                cells = new Array(boardConfig.width * boardConfig.height).fill(null).map((_, index) => {
                    const cellButton = document.createElement('button');
                    cellButton.className = 'cell hidden';
                    cellButton.type = 'button';
                    cellButton.setAttribute('data-index', index);
                    cellButton.setAttribute('aria-label', 'ë‹«íŒ ì¹¸');
                    cellButton.addEventListener('click', handleReveal);
                    cellButton.addEventListener('contextmenu', handleFlag);
                    cellButton.addEventListener('auxclick', event => {
                        if (event.button === 1) {
                            event.preventDefault();
                            handleChord(event);
                        }
                    });
                    cellButton.addEventListener('pointerdown', event => handlePointerDown(event, index));
                    cellButton.addEventListener('pointerup', event => handlePointerUp(event, index));
                    cellButton.addEventListener('pointerleave', event => cancelPointerTimer(event.pointerId));
                    cellButton.addEventListener('pointercancel', event => cancelPointerTimer(event.pointerId));

                    minefieldEl.appendChild(cellButton);
                    return {
                        element: cellButton,
                        mine: false,
                        adjacent: 0,
                        revealed: false,
                        flagged: false
                    };
                });

                updateStats();
                setStatus('ì²« ì¹¸ì„ ì—´ì–´ë³´ì„¸ìš”! ê¸¸ê²Œ ëˆŒëŸ¬ ê¹ƒë°œì„ í‘œì‹œí•  ìˆ˜ ìˆì–´ìš”.');
            }

            function generateBoard(firstIndex) {
                const availableIndices = cells.map((_, i) => i).filter(i => i !== firstIndex);
                shuffleArray(availableIndices);
                const mineIndices = availableIndices.slice(0, boardConfig.mines);

                mineIndices.forEach(i => {
                    cells[i].mine = true;
                });

                cells.forEach((cell, index) => {
                    if (cell.mine) return;
                    const { x, y } = xyFromIndex(index);
                    const neighbors = getNeighbors(x, y);
                    cell.adjacent = neighbors.filter(n => cells[n.index].mine).length;
                });

                boardGenerated = true;
            }

            function xyFromIndex(index) {
                const x = index % boardConfig.width;
                const y = Math.floor(index / boardConfig.width);
                return { x, y };
            }

            function shuffleArray(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
            }

            function handleReveal(event) {
                event.preventDefault();
                const index = Number(event.currentTarget.dataset.index);
                attemptReveal(index);
            }

            function attemptReveal(index) {
                if (gameOver) return;
                const cell = cells[index];
                if (cell.revealed || cell.flagged) return;

                if (!boardGenerated) {
                    generateBoard(index);
                    startTimer();
                }

                revealCell(index);
                checkWinCondition();
            }

            function revealCell(index) {
                const cell = cells[index];
                if (cell.revealed || cell.flagged) return;

                cell.revealed = true;
                cell.element.classList.remove('hidden');
                cell.element.classList.add('revealed');
                cell.element.setAttribute('aria-pressed', 'true');
                revealedCount += 1;

                if (cell.mine) {
                    cell.element.classList.add('mine');
                    cell.element.textContent = 'ğŸ’£';
                    endGame(false);
                    return;
                }

                if (cell.adjacent > 0) {
                    cell.element.textContent = cell.adjacent;
                    cell.element.dataset.count = cell.adjacent;
                } else {
                    const { x, y } = xyFromIndex(index);
                    getNeighbors(x, y).forEach(({ index: neighborIndex }) => {
                        revealCell(neighborIndex);
                    });
                }
            }

            function handleFlag(event) {
                event.preventDefault();
                const index = Number(event.currentTarget.dataset.index);
                toggleFlag(index);
            }

            function toggleFlag(index) {
                if (gameOver) return;
                const cell = cells[index];
                if (cell.revealed) return;

                cell.flagged = !cell.flagged;
                if (cell.flagged) {
                    cell.element.classList.add('flagged');
                    cell.element.textContent = 'ğŸš©';
                    cell.element.setAttribute('aria-label', 'ê¹ƒë°œ í‘œì‹œëœ ì¹¸');
                    flagCount += 1;
                } else {
                    cell.element.classList.remove('flagged');
                    cell.element.textContent = '';
                    cell.element.setAttribute('aria-label', 'ë‹«íŒ ì¹¸');
                    flagCount -= 1;
                }
                updateStats();
                checkWinCondition();
            }

            function handleChord(event) {
                const index = Number(event.currentTarget.dataset.index);
                const cell = cells[index];
                if (!cell.revealed || cell.adjacent === 0) return;

                const { x, y } = xyFromIndex(index);
                const neighbors = getNeighbors(x, y);
                const flaggedNeighbors = neighbors.filter(n => cells[n.index].flagged).length;
                if (flaggedNeighbors !== cell.adjacent) return;

                neighbors.forEach(n => {
                    if (!cells[n.index].flagged) {
                        revealCell(n.index);
                    }
                });
                checkWinCondition();
            }

            function revealAllMines() {
                cells.forEach(cell => {
                    if (cell.mine) {
                        cell.element.classList.remove('hidden');
                        cell.element.classList.add('revealed', 'mine');
                        cell.element.textContent = 'ğŸ’£';
                    }
                });
            }

            function endGame(won) {
                gameOver = true;
                stopTimer();
                if (won) {
                    setStatus('ì¶•í•˜í•©ë‹ˆë‹¤! ëª¨ë“  ì§€ë¢°ë¥¼ ì°¾ì•˜ìŠµë‹ˆë‹¤.');
                } else {
                    setStatus('ì§€ë¢°ë¥¼ ë°Ÿì•˜ì–´ìš”! ë‹¤ì‹œ ë„ì „í•´ë³´ì„¸ìš”.');
                    revealAllMines();
                }
                cells.forEach(cell => cell.element.disabled = true);
            }

            function checkWinCondition() {
                if (gameOver) return;
                const totalCells = boardConfig.width * boardConfig.height;
                if (revealedCount + boardConfig.mines === totalCells) {
                    endGame(true);
                }
            }

            function handlePointerDown(event, index) {
                if (event.pointerType !== 'touch' && event.pointerType !== 'pen') return;
                if (gameOver) return;
                event.preventDefault();
                cancelPointerTimer(event.pointerId);
                const state = {
                    index,
                    longPressTriggered: false
                };
                state.timerId = setTimeout(() => {
                    state.longPressTriggered = true;
                    toggleFlag(index);
                }, LONG_PRESS_DELAY);
                pointerTimers.set(event.pointerId, state);
            }

            function handlePointerUp(event, index) {
                if (event.pointerType !== 'touch' && event.pointerType !== 'pen') return;
                event.preventDefault();
                const state = pointerTimers.get(event.pointerId);
                if (state) {
                    clearTimeout(state.timerId);
                    pointerTimers.delete(event.pointerId);
                    if (!state.longPressTriggered) {
                        attemptReveal(index);
                    }
                } else {
                    attemptReveal(index);
                }
            }

            function cancelPointerTimer(pointerId) {
                const state = pointerTimers.get(pointerId);
                if (state) {
                    clearTimeout(state.timerId);
                    pointerTimers.delete(pointerId);
                }
            }

            difficultyEl.addEventListener('change', resetGame);
            resetBtn.addEventListener('click', resetGame);
            minefieldEl.addEventListener('contextmenu', event => event.preventDefault());

            resetGame();
        })();
    </script>
</body>
</html>
